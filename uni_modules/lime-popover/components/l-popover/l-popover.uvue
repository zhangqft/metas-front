<template>
	<view <!-- #ifndef APP -->
		@click.stop="handleClick"
		ref="referenceRef"
		<!-- #endif -->
		class="l-popover__wrapper"
		>
		<slot />
		<view 
			v-if="innerVisible || display" 
			class="l-popover"
			:class="['l-popover--' + innerPlacement, 'l-popover--' + theme, classes]" 
			:style="[popoverStyle, styles]"
			ref="popoverRef" 
			@animationend="finished">

			<view 
				v-if="showArrow" 
				class="l-popover__arrow" 
				:class="['l-popover__arrow--' + innerPlacement]">
			</view>

			<view class="l-popover__content" 
				:class="['l-popover__content--' + innerPlacement]">
				<slot name="content">
					<text class="l-popover__text">{{content}}</text>
				</slot>
			</view>
		</view>
		<!-- #ifndef APP || WEB -->
		<view class="l-popover__mark" v-if="innerVisible && closeOnClickOutside" @touchstart="handleMark"></view>
		<!-- #endif -->
	</view>
</template>
<script lang="uts" setup>
	/**
	 * Popover 气泡弹出层组件
	 * @description 用于显示上下文相关的信息或操作菜单，支持多种定位方式和主题样式
	 * <br>插件类型：LPopoverComponentPublicInstance 
	 * @tutorial https://ext.dcloud.net.cn/plugin?name=lime-popover
	 * 
	 * @property {boolean} closeOnClickOutside 点击外部关闭（默认：true）
	 * @property {string} content 显示内容
	 * @property {string} placement 弹出位置（默认：'top'）
	 * @value top          顶部居中
	 * @value top-left     顶部左侧
	 * @value top-right    顶部右侧
	 * @value bottom       底部居中
	 * @value bottom-left  底部左侧
	 * @value bottom-right 底部右侧
	 * @value left         左侧居中
	 * @value left-top     左侧上方
	 * @value left-bottom  左侧下方
	 * @value right        右侧居中
	 * @value right-top    右侧上方
	 * @value right-bottom 右侧下方
	 * @property {boolean} showArrow 显示定位箭头（默认：true）
	 * @property {'dark' | 'light'} theme 主题样式
	 * @property {'dark' | 'light'} theme 主题样式（默认：'dark'）
	 * @value light   
	 * @value dark 
	 * @property {boolean} visible 控制显示/隐藏（支持v-model）
	 * @property {string} color 自定义主色（覆盖主题色）
	 */

	import { PopoverProps, PlacementAndWidth } from './type';
	import { useTransition, UseTransitionOptions, TransitionEmitStatus } from '@/uni_modules/lime-transition';
	import { getRect } from '@/uni_modules/lime-shared/getRect'
	import { pushToQueue, removeFromQueue, closeOther } from '@/uni_modules/lime-popover';
	import { getPopoverPlacement, PopoverPlacementOptions } from './utils';

	const props = withDefaults(defineProps<PopoverProps>(), {
		closeOnClickOutside: true,
		placement: 'top',
		showArrow: true,
		disabled: false,
		theme: 'light',
		visible: null,
		duration: 150,
	})
	const modelValue = defineModel({ type: Boolean, default: false })
	const transitionVisible = ref(false);
	const innerVisible = computed({
		set(v : boolean) {
			modelValue.value = v;
		},
		get() : boolean {
			return props.visible ?? modelValue.value
		}
	} as WritableComputedOptions<boolean>)
	const popoverStyle = ref({})


	const instance = getCurrentInstance()!
	pushToQueue(instance.proxy!);
	
	const referenceRef = ref<UniElement | null>(null);
	const popoverRef = ref<UniElement | null>(null);
	const innerPlacement = ref(props.placement);
	const { inited, display, classes, finished, toggle } = useTransition({
		defaultName: 'popover-animation',
		removeClasses: true,
		visible: () : boolean => transitionVisible.value,
		duration: props.duration,
	} as UseTransitionOptions)

	const styles = computed(() : Map<string, any> => {
		const style = new Map<string, any>()
		if (!['light', 'dark'].includes(props.theme)) {
			style.set('--l-popover-bg-color', props.theme)
			style.set('--l-popover-color', props.color ?? 'white')
		}
		return style
	})

	const close = () => {
		innerVisible.value = false;
	}
	
	let markTime = Date.now()
	const handleMark = (e : UniTouchEvent) => {
		markTime = Date.now()
		// e.preventDefault()
		close()
	}
	
	let clickTimer = -1
	const outsideClick = (e : UniPointerEvent) => {
		if (!props.closeOnClickOutside || !innerVisible.value) return
		// #ifdef APP || WEB

		// 检查点击目标是否在内部å
		// const target = findPageElement(e.target, 'l-popover__wrapper')
		// if (target == referenceRef.value) return
		// #endif
		// 因为是touchstart所以延时一下
		// clickTimer = setTimeout(()=>{
			close()
		// },300)
	}
	const handleClick = (e : UniPointerEvent) => {
		// 微信小程序点击遮罩 会有可能触发底层的点击事件
		if (Date.now() - markTime < 200 || props.disabled) return
		e.stopPropagation()
		closeOther(instance.proxy!)
		innerVisible.value = !innerVisible.value
	}

	const getAndSetPosition = async () => {
		if (referenceRef.value == null || popoverRef.value == null) return
		const referenceRect = await referenceRef.value!.getBoundingClientRectAsync()!
		const contentRect = await popoverRef.value!.getBoundingClientRectAsync()!
		const { points: [popperPosition], placement } = getPopoverPlacement(referenceRect, contentRect, {
			position: props.placement,
			refGap: 5,
			viewportGap: 10,
			arrowSize: 16
		} as PopoverPlacementOptions)

		// #ifndef APP
		popoverStyle.value = {
			top: `calc(${popperPosition.top}px + var(--window-top))`,
			left: popperPosition.left + "px",
		}
		// #endif
		// #ifdef APP
		popoverRef.value?.style.setProperty('top', `${popperPosition.top}px`)
		popoverRef.value?.style.setProperty('left', `${popperPosition.left}px`)
		// #endif
		transitionVisible.value = true;
		innerPlacement.value = placement
	}
	watch(innerVisible, (v : boolean) => {
		if (v) {
			nextTick(() => {
				// 小程序需要延时
				// #ifdef APP
				requestAnimationFrame(()=>{
				// #endif
					setTimeout(() => {
						getAndSetPosition();
					}, 50)
				// #ifdef APP	
				})
				// #endif
			})
		} else {
			transitionVisible.value = false;
		}
	})

	
	// #ifdef APP
	let pageElementCallbackWrapper : UniCallbackWrapper | null = null
	let targetCallbackWrapper : UniCallbackWrapper | null = null
	let touchStartWrapper  : UniCallbackWrapper | null = null
	let touchEndWrapper  : UniCallbackWrapper | null = null
	
	// #endif

	onMounted(() => {
		nextTick(() => {
			// #ifdef WEB
			window.addEventListener('click', outsideClick)
			// #endif

			// #ifdef APP
			for (let i = 0; i < instance.proxy!.$el!.children.length; i++) {
				const el = instance.proxy!.$el!.children[i]
				if (!['#text', '#comment'].includes(el.nodeName)) {
					referenceRef.value = el
					break;
				}
			}
			targetCallbackWrapper = referenceRef.value?.addEventListener('click', handleClick)
			pageElementCallbackWrapper = instance.proxy?.$el?.uniPage.vm.$el.addEventListener('click', outsideClick)
			// #endif
		})

	})

	onBeforeUnmount(() => {
		// 清理定时器和事件
		clearTimeout(clickTimer!)
		close()
		// 移除全局点击监听
		// #ifdef WEB
		window.removeEventListener('click', outsideClick!)
		// #endif
		// #ifdef APP
		if (targetCallbackWrapper != null) {
			referenceRef.value?.removeEventListener('click', targetCallbackWrapper!)
		}
		if (pageElementCallbackWrapper != null) {
			instance.proxy?.$el?.uniPage.vm.$el.removeEventListener('click', pageElementCallbackWrapper!)
			pageElementCallbackWrapper = null
		}
		// #endif
		removeFromQueue(instance.proxy!)
	})
	
	const scrollTimer = ref<number | null>(null)
	const isScrolling = ref(false)
	
	
	const handleScroll = () => {
	  if (!innerVisible.value) return
	  
	  // 隐藏逻辑
	  if (!isScrolling.value) {
	    transitionVisible.value = false
	    isScrolling.value = true
	  }
	  
	  // 清除旧定时器
	  if (scrollTimer.value != null) {
	    clearTimeout(scrollTimer.value!)
	  }
	  
	  // 延迟显示逻辑
	  scrollTimer.value = setTimeout(() => {
	    isScrolling.value = false
	    getAndSetPosition()
	    transitionVisible.value = true
	  }, 300)
	}
	
	watch(():number|null => props.scrollPosition, () => {
	  handleScroll()
	})
	
	// #ifdef APP || WEB
	onPageScroll((_e : OnPageScrollOptions) => {
		// 只有未传入scrollPosition时才使用onPageScroll
		if (props.scrollPosition == null) { 
		    handleScroll()
		  }
	})
	// #endif
	
	defineExpose({
		close
	})
	
</script>
<style lang="scss">
	@import './index';
</style>